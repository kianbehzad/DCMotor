// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: messages_parsian_simurosot_debugs.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_messages_5fparsian_5fsimurosot_5fdebugs_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_messages_5fparsian_5fsimurosot_5fdebugs_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3011000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3011002 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_messages_5fparsian_5fsimurosot_5fdebugs_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_messages_5fparsian_5fsimurosot_5fdebugs_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[11]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_messages_5fparsian_5fsimurosot_5fdebugs_2eproto;
class Cir2D;
class Cir2DDefaultTypeInternal;
extern Cir2DDefaultTypeInternal _Cir2D_default_instance_;
class Color;
class ColorDefaultTypeInternal;
extern ColorDefaultTypeInternal _Color_default_instance_;
class Draws;
class DrawsDefaultTypeInternal;
extern DrawsDefaultTypeInternal _Draws_default_instance_;
class Log;
class LogDefaultTypeInternal;
extern LogDefaultTypeInternal _Log_default_instance_;
class Logs;
class LogsDefaultTypeInternal;
extern LogsDefaultTypeInternal _Logs_default_instance_;
class Pol2D;
class Pol2DDefaultTypeInternal;
extern Pol2DDefaultTypeInternal _Pol2D_default_instance_;
class Rec2D;
class Rec2DDefaultTypeInternal;
extern Rec2DDefaultTypeInternal _Rec2D_default_instance_;
class Seg2D;
class Seg2DDefaultTypeInternal;
extern Seg2DDefaultTypeInternal _Seg2D_default_instance_;
class Tex2D;
class Tex2DDefaultTypeInternal;
extern Tex2DDefaultTypeInternal _Tex2D_default_instance_;
class Vec2;
class Vec2DefaultTypeInternal;
extern Vec2DefaultTypeInternal _Vec2_default_instance_;
class Vec2D;
class Vec2DDefaultTypeInternal;
extern Vec2DDefaultTypeInternal _Vec2D_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::Cir2D* Arena::CreateMaybeMessage<::Cir2D>(Arena*);
template<> ::Color* Arena::CreateMaybeMessage<::Color>(Arena*);
template<> ::Draws* Arena::CreateMaybeMessage<::Draws>(Arena*);
template<> ::Log* Arena::CreateMaybeMessage<::Log>(Arena*);
template<> ::Logs* Arena::CreateMaybeMessage<::Logs>(Arena*);
template<> ::Pol2D* Arena::CreateMaybeMessage<::Pol2D>(Arena*);
template<> ::Rec2D* Arena::CreateMaybeMessage<::Rec2D>(Arena*);
template<> ::Seg2D* Arena::CreateMaybeMessage<::Seg2D>(Arena*);
template<> ::Tex2D* Arena::CreateMaybeMessage<::Tex2D>(Arena*);
template<> ::Vec2* Arena::CreateMaybeMessage<::Vec2>(Arena*);
template<> ::Vec2D* Arena::CreateMaybeMessage<::Vec2D>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

enum LogLevel : int {
  LL_DEBUG = 0,
  LL_INFO = 1,
  LL_WARN = 2,
  LL_ERROR = 3,
  LL_FATAL = 4,
  LogLevel_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  LogLevel_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool LogLevel_IsValid(int value);
constexpr LogLevel LogLevel_MIN = LL_DEBUG;
constexpr LogLevel LogLevel_MAX = LL_FATAL;
constexpr int LogLevel_ARRAYSIZE = LogLevel_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LogLevel_descriptor();
template<typename T>
inline const std::string& LogLevel_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LogLevel>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LogLevel_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    LogLevel_descriptor(), enum_t_value);
}
inline bool LogLevel_Parse(
    const std::string& name, LogLevel* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<LogLevel>(
    LogLevel_descriptor(), name, value);
}
// ===================================================================

class Color :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Color) */ {
 public:
  Color();
  virtual ~Color();

  Color(const Color& from);
  Color(Color&& from) noexcept
    : Color() {
    *this = ::std::move(from);
  }

  inline Color& operator=(const Color& from) {
    CopyFrom(from);
    return *this;
  }
  inline Color& operator=(Color&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Color& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Color* internal_default_instance() {
    return reinterpret_cast<const Color*>(
               &_Color_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Color& a, Color& b) {
    a.Swap(&b);
  }
  inline void Swap(Color* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Color* New() const final {
    return CreateMaybeMessage<Color>(nullptr);
  }

  Color* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Color>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Color& from);
  void MergeFrom(const Color& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Color* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Color";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_messages_5fparsian_5fsimurosot_5fdebugs_2eproto);
    return ::descriptor_table_messages_5fparsian_5fsimurosot_5fdebugs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRFieldNumber = 1,
    kGFieldNumber = 2,
    kBFieldNumber = 3,
    kAFieldNumber = 4,
  };
  // float r = 1;
  void clear_r();
  float r() const;
  void set_r(float value);
  private:
  float _internal_r() const;
  void _internal_set_r(float value);
  public:

  // float g = 2;
  void clear_g();
  float g() const;
  void set_g(float value);
  private:
  float _internal_g() const;
  void _internal_set_g(float value);
  public:

  // float b = 3;
  void clear_b();
  float b() const;
  void set_b(float value);
  private:
  float _internal_b() const;
  void _internal_set_b(float value);
  public:

  // float a = 4;
  void clear_a();
  float a() const;
  void set_a(float value);
  private:
  float _internal_a() const;
  void _internal_set_a(float value);
  public:

  // @@protoc_insertion_point(class_scope:Color)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  float r_;
  float g_;
  float b_;
  float a_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_messages_5fparsian_5fsimurosot_5fdebugs_2eproto;
};
// -------------------------------------------------------------------

class Vec2 :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Vec2) */ {
 public:
  Vec2();
  virtual ~Vec2();

  Vec2(const Vec2& from);
  Vec2(Vec2&& from) noexcept
    : Vec2() {
    *this = ::std::move(from);
  }

  inline Vec2& operator=(const Vec2& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vec2& operator=(Vec2&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Vec2& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Vec2* internal_default_instance() {
    return reinterpret_cast<const Vec2*>(
               &_Vec2_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Vec2& a, Vec2& b) {
    a.Swap(&b);
  }
  inline void Swap(Vec2* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Vec2* New() const final {
    return CreateMaybeMessage<Vec2>(nullptr);
  }

  Vec2* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Vec2>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Vec2& from);
  void MergeFrom(const Vec2& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vec2* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Vec2";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_messages_5fparsian_5fsimurosot_5fdebugs_2eproto);
    return ::descriptor_table_messages_5fparsian_5fsimurosot_5fdebugs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
  };
  // float x = 1;
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // float y = 2;
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // @@protoc_insertion_point(class_scope:Vec2)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  float x_;
  float y_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_messages_5fparsian_5fsimurosot_5fdebugs_2eproto;
};
// -------------------------------------------------------------------

class Vec2D :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Vec2D) */ {
 public:
  Vec2D();
  virtual ~Vec2D();

  Vec2D(const Vec2D& from);
  Vec2D(Vec2D&& from) noexcept
    : Vec2D() {
    *this = ::std::move(from);
  }

  inline Vec2D& operator=(const Vec2D& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vec2D& operator=(Vec2D&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Vec2D& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Vec2D* internal_default_instance() {
    return reinterpret_cast<const Vec2D*>(
               &_Vec2D_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Vec2D& a, Vec2D& b) {
    a.Swap(&b);
  }
  inline void Swap(Vec2D* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Vec2D* New() const final {
    return CreateMaybeMessage<Vec2D>(nullptr);
  }

  Vec2D* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Vec2D>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Vec2D& from);
  void MergeFrom(const Vec2D& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vec2D* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Vec2D";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_messages_5fparsian_5fsimurosot_5fdebugs_2eproto);
    return ::descriptor_table_messages_5fparsian_5fsimurosot_5fdebugs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColorFieldNumber = 3,
    kXFieldNumber = 1,
    kYFieldNumber = 2,
  };
  // .Color color = 3;
  bool has_color() const;
  private:
  bool _internal_has_color() const;
  public:
  void clear_color();
  const ::Color& color() const;
  ::Color* release_color();
  ::Color* mutable_color();
  void set_allocated_color(::Color* color);
  private:
  const ::Color& _internal_color() const;
  ::Color* _internal_mutable_color();
  public:

  // float x = 1;
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // float y = 2;
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // @@protoc_insertion_point(class_scope:Vec2D)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::Color* color_;
  float x_;
  float y_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_messages_5fparsian_5fsimurosot_5fdebugs_2eproto;
};
// -------------------------------------------------------------------

class Cir2D :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Cir2D) */ {
 public:
  Cir2D();
  virtual ~Cir2D();

  Cir2D(const Cir2D& from);
  Cir2D(Cir2D&& from) noexcept
    : Cir2D() {
    *this = ::std::move(from);
  }

  inline Cir2D& operator=(const Cir2D& from) {
    CopyFrom(from);
    return *this;
  }
  inline Cir2D& operator=(Cir2D&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Cir2D& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Cir2D* internal_default_instance() {
    return reinterpret_cast<const Cir2D*>(
               &_Cir2D_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Cir2D& a, Cir2D& b) {
    a.Swap(&b);
  }
  inline void Swap(Cir2D* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Cir2D* New() const final {
    return CreateMaybeMessage<Cir2D>(nullptr);
  }

  Cir2D* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Cir2D>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Cir2D& from);
  void MergeFrom(const Cir2D& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Cir2D* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Cir2D";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_messages_5fparsian_5fsimurosot_5fdebugs_2eproto);
    return ::descriptor_table_messages_5fparsian_5fsimurosot_5fdebugs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCenterFieldNumber = 1,
    kColorFieldNumber = 6,
    kStartAngleFieldNumber = 2,
    kEndAngleFieldNumber = 3,
    kRadiusFieldNumber = 4,
    kFillFieldNumber = 5,
  };
  // .Vec2 center = 1;
  bool has_center() const;
  private:
  bool _internal_has_center() const;
  public:
  void clear_center();
  const ::Vec2& center() const;
  ::Vec2* release_center();
  ::Vec2* mutable_center();
  void set_allocated_center(::Vec2* center);
  private:
  const ::Vec2& _internal_center() const;
  ::Vec2* _internal_mutable_center();
  public:

  // .Color color = 6;
  bool has_color() const;
  private:
  bool _internal_has_color() const;
  public:
  void clear_color();
  const ::Color& color() const;
  ::Color* release_color();
  ::Color* mutable_color();
  void set_allocated_color(::Color* color);
  private:
  const ::Color& _internal_color() const;
  ::Color* _internal_mutable_color();
  public:

  // float startAngle = 2;
  void clear_startangle();
  float startangle() const;
  void set_startangle(float value);
  private:
  float _internal_startangle() const;
  void _internal_set_startangle(float value);
  public:

  // float endAngle = 3;
  void clear_endangle();
  float endangle() const;
  void set_endangle(float value);
  private:
  float _internal_endangle() const;
  void _internal_set_endangle(float value);
  public:

  // float radius = 4;
  void clear_radius();
  float radius() const;
  void set_radius(float value);
  private:
  float _internal_radius() const;
  void _internal_set_radius(float value);
  public:

  // bool fill = 5;
  void clear_fill();
  bool fill() const;
  void set_fill(bool value);
  private:
  bool _internal_fill() const;
  void _internal_set_fill(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Cir2D)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::Vec2* center_;
  ::Color* color_;
  float startangle_;
  float endangle_;
  float radius_;
  bool fill_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_messages_5fparsian_5fsimurosot_5fdebugs_2eproto;
};
// -------------------------------------------------------------------

class Seg2D :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Seg2D) */ {
 public:
  Seg2D();
  virtual ~Seg2D();

  Seg2D(const Seg2D& from);
  Seg2D(Seg2D&& from) noexcept
    : Seg2D() {
    *this = ::std::move(from);
  }

  inline Seg2D& operator=(const Seg2D& from) {
    CopyFrom(from);
    return *this;
  }
  inline Seg2D& operator=(Seg2D&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Seg2D& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Seg2D* internal_default_instance() {
    return reinterpret_cast<const Seg2D*>(
               &_Seg2D_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Seg2D& a, Seg2D& b) {
    a.Swap(&b);
  }
  inline void Swap(Seg2D* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Seg2D* New() const final {
    return CreateMaybeMessage<Seg2D>(nullptr);
  }

  Seg2D* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Seg2D>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Seg2D& from);
  void MergeFrom(const Seg2D& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Seg2D* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Seg2D";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_messages_5fparsian_5fsimurosot_5fdebugs_2eproto);
    return ::descriptor_table_messages_5fparsian_5fsimurosot_5fdebugs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOriginFieldNumber = 1,
    kTerminalFieldNumber = 2,
    kColorFieldNumber = 3,
  };
  // .Vec2 origin = 1;
  bool has_origin() const;
  private:
  bool _internal_has_origin() const;
  public:
  void clear_origin();
  const ::Vec2& origin() const;
  ::Vec2* release_origin();
  ::Vec2* mutable_origin();
  void set_allocated_origin(::Vec2* origin);
  private:
  const ::Vec2& _internal_origin() const;
  ::Vec2* _internal_mutable_origin();
  public:

  // .Vec2 terminal = 2;
  bool has_terminal() const;
  private:
  bool _internal_has_terminal() const;
  public:
  void clear_terminal();
  const ::Vec2& terminal() const;
  ::Vec2* release_terminal();
  ::Vec2* mutable_terminal();
  void set_allocated_terminal(::Vec2* terminal);
  private:
  const ::Vec2& _internal_terminal() const;
  ::Vec2* _internal_mutable_terminal();
  public:

  // .Color color = 3;
  bool has_color() const;
  private:
  bool _internal_has_color() const;
  public:
  void clear_color();
  const ::Color& color() const;
  ::Color* release_color();
  ::Color* mutable_color();
  void set_allocated_color(::Color* color);
  private:
  const ::Color& _internal_color() const;
  ::Color* _internal_mutable_color();
  public:

  // @@protoc_insertion_point(class_scope:Seg2D)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::Vec2* origin_;
  ::Vec2* terminal_;
  ::Color* color_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_messages_5fparsian_5fsimurosot_5fdebugs_2eproto;
};
// -------------------------------------------------------------------

class Rec2D :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Rec2D) */ {
 public:
  Rec2D();
  virtual ~Rec2D();

  Rec2D(const Rec2D& from);
  Rec2D(Rec2D&& from) noexcept
    : Rec2D() {
    *this = ::std::move(from);
  }

  inline Rec2D& operator=(const Rec2D& from) {
    CopyFrom(from);
    return *this;
  }
  inline Rec2D& operator=(Rec2D&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Rec2D& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Rec2D* internal_default_instance() {
    return reinterpret_cast<const Rec2D*>(
               &_Rec2D_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Rec2D& a, Rec2D& b) {
    a.Swap(&b);
  }
  inline void Swap(Rec2D* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Rec2D* New() const final {
    return CreateMaybeMessage<Rec2D>(nullptr);
  }

  Rec2D* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Rec2D>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Rec2D& from);
  void MergeFrom(const Rec2D& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Rec2D* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Rec2D";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_messages_5fparsian_5fsimurosot_5fdebugs_2eproto);
    return ::descriptor_table_messages_5fparsian_5fsimurosot_5fdebugs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTopLeftFieldNumber = 1,
    kBotRightFieldNumber = 2,
    kColorFieldNumber = 3,
    kFillFieldNumber = 4,
  };
  // .Vec2 topLeft = 1;
  bool has_topleft() const;
  private:
  bool _internal_has_topleft() const;
  public:
  void clear_topleft();
  const ::Vec2& topleft() const;
  ::Vec2* release_topleft();
  ::Vec2* mutable_topleft();
  void set_allocated_topleft(::Vec2* topleft);
  private:
  const ::Vec2& _internal_topleft() const;
  ::Vec2* _internal_mutable_topleft();
  public:

  // .Vec2 BotRight = 2;
  bool has_botright() const;
  private:
  bool _internal_has_botright() const;
  public:
  void clear_botright();
  const ::Vec2& botright() const;
  ::Vec2* release_botright();
  ::Vec2* mutable_botright();
  void set_allocated_botright(::Vec2* botright);
  private:
  const ::Vec2& _internal_botright() const;
  ::Vec2* _internal_mutable_botright();
  public:

  // .Color color = 3;
  bool has_color() const;
  private:
  bool _internal_has_color() const;
  public:
  void clear_color();
  const ::Color& color() const;
  ::Color* release_color();
  ::Color* mutable_color();
  void set_allocated_color(::Color* color);
  private:
  const ::Color& _internal_color() const;
  ::Color* _internal_mutable_color();
  public:

  // bool fill = 4;
  void clear_fill();
  bool fill() const;
  void set_fill(bool value);
  private:
  bool _internal_fill() const;
  void _internal_set_fill(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Rec2D)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::Vec2* topleft_;
  ::Vec2* botright_;
  ::Color* color_;
  bool fill_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_messages_5fparsian_5fsimurosot_5fdebugs_2eproto;
};
// -------------------------------------------------------------------

class Tex2D :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Tex2D) */ {
 public:
  Tex2D();
  virtual ~Tex2D();

  Tex2D(const Tex2D& from);
  Tex2D(Tex2D&& from) noexcept
    : Tex2D() {
    *this = ::std::move(from);
  }

  inline Tex2D& operator=(const Tex2D& from) {
    CopyFrom(from);
    return *this;
  }
  inline Tex2D& operator=(Tex2D&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Tex2D& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Tex2D* internal_default_instance() {
    return reinterpret_cast<const Tex2D*>(
               &_Tex2D_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Tex2D& a, Tex2D& b) {
    a.Swap(&b);
  }
  inline void Swap(Tex2D* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Tex2D* New() const final {
    return CreateMaybeMessage<Tex2D>(nullptr);
  }

  Tex2D* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Tex2D>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Tex2D& from);
  void MergeFrom(const Tex2D& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Tex2D* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Tex2D";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_messages_5fparsian_5fsimurosot_5fdebugs_2eproto);
    return ::descriptor_table_messages_5fparsian_5fsimurosot_5fdebugs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 4,
    kPosFieldNumber = 1,
    kColorFieldNumber = 3,
    kSizeFieldNumber = 2,
  };
  // string data = 4;
  void clear_data();
  const std::string& data() const;
  void set_data(const std::string& value);
  void set_data(std::string&& value);
  void set_data(const char* value);
  void set_data(const char* value, size_t size);
  std::string* mutable_data();
  std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // .Vec2 pos = 1;
  bool has_pos() const;
  private:
  bool _internal_has_pos() const;
  public:
  void clear_pos();
  const ::Vec2& pos() const;
  ::Vec2* release_pos();
  ::Vec2* mutable_pos();
  void set_allocated_pos(::Vec2* pos);
  private:
  const ::Vec2& _internal_pos() const;
  ::Vec2* _internal_mutable_pos();
  public:

  // .Color color = 3;
  bool has_color() const;
  private:
  bool _internal_has_color() const;
  public:
  void clear_color();
  const ::Color& color() const;
  ::Color* release_color();
  ::Color* mutable_color();
  void set_allocated_color(::Color* color);
  private:
  const ::Color& _internal_color() const;
  ::Color* _internal_mutable_color();
  public:

  // float size = 2;
  void clear_size();
  float size() const;
  void set_size(float value);
  private:
  float _internal_size() const;
  void _internal_set_size(float value);
  public:

  // @@protoc_insertion_point(class_scope:Tex2D)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
  ::Vec2* pos_;
  ::Color* color_;
  float size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_messages_5fparsian_5fsimurosot_5fdebugs_2eproto;
};
// -------------------------------------------------------------------

class Pol2D :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Pol2D) */ {
 public:
  Pol2D();
  virtual ~Pol2D();

  Pol2D(const Pol2D& from);
  Pol2D(Pol2D&& from) noexcept
    : Pol2D() {
    *this = ::std::move(from);
  }

  inline Pol2D& operator=(const Pol2D& from) {
    CopyFrom(from);
    return *this;
  }
  inline Pol2D& operator=(Pol2D&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Pol2D& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Pol2D* internal_default_instance() {
    return reinterpret_cast<const Pol2D*>(
               &_Pol2D_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Pol2D& a, Pol2D& b) {
    a.Swap(&b);
  }
  inline void Swap(Pol2D* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Pol2D* New() const final {
    return CreateMaybeMessage<Pol2D>(nullptr);
  }

  Pol2D* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Pol2D>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Pol2D& from);
  void MergeFrom(const Pol2D& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Pol2D* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Pol2D";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_messages_5fparsian_5fsimurosot_5fdebugs_2eproto);
    return ::descriptor_table_messages_5fparsian_5fsimurosot_5fdebugs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVectorsFieldNumber = 1,
    kColorFieldNumber = 2,
    kFillFieldNumber = 3,
  };
  // repeated .Vec2 vectors = 1;
  int vectors_size() const;
  private:
  int _internal_vectors_size() const;
  public:
  void clear_vectors();
  ::Vec2* mutable_vectors(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Vec2 >*
      mutable_vectors();
  private:
  const ::Vec2& _internal_vectors(int index) const;
  ::Vec2* _internal_add_vectors();
  public:
  const ::Vec2& vectors(int index) const;
  ::Vec2* add_vectors();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Vec2 >&
      vectors() const;

  // .Color color = 2;
  bool has_color() const;
  private:
  bool _internal_has_color() const;
  public:
  void clear_color();
  const ::Color& color() const;
  ::Color* release_color();
  ::Color* mutable_color();
  void set_allocated_color(::Color* color);
  private:
  const ::Color& _internal_color() const;
  ::Color* _internal_mutable_color();
  public:

  // bool fill = 3;
  void clear_fill();
  bool fill() const;
  void set_fill(bool value);
  private:
  bool _internal_fill() const;
  void _internal_set_fill(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Pol2D)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Vec2 > vectors_;
  ::Color* color_;
  bool fill_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_messages_5fparsian_5fsimurosot_5fdebugs_2eproto;
};
// -------------------------------------------------------------------

class Draws :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Draws) */ {
 public:
  Draws();
  virtual ~Draws();

  Draws(const Draws& from);
  Draws(Draws&& from) noexcept
    : Draws() {
    *this = ::std::move(from);
  }

  inline Draws& operator=(const Draws& from) {
    CopyFrom(from);
    return *this;
  }
  inline Draws& operator=(Draws&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Draws& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Draws* internal_default_instance() {
    return reinterpret_cast<const Draws*>(
               &_Draws_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Draws& a, Draws& b) {
    a.Swap(&b);
  }
  inline void Swap(Draws* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Draws* New() const final {
    return CreateMaybeMessage<Draws>(nullptr);
  }

  Draws* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Draws>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Draws& from);
  void MergeFrom(const Draws& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Draws* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Draws";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_messages_5fparsian_5fsimurosot_5fdebugs_2eproto);
    return ::descriptor_table_messages_5fparsian_5fsimurosot_5fdebugs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVectorsFieldNumber = 1,
    kCirclesFieldNumber = 2,
    kSegmentsFieldNumber = 3,
    kRectsFieldNumber = 4,
    kPolygonsFieldNumber = 5,
    kTextsFieldNumber = 6,
  };
  // repeated .Vec2D vectors = 1;
  int vectors_size() const;
  private:
  int _internal_vectors_size() const;
  public:
  void clear_vectors();
  ::Vec2D* mutable_vectors(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Vec2D >*
      mutable_vectors();
  private:
  const ::Vec2D& _internal_vectors(int index) const;
  ::Vec2D* _internal_add_vectors();
  public:
  const ::Vec2D& vectors(int index) const;
  ::Vec2D* add_vectors();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Vec2D >&
      vectors() const;

  // repeated .Cir2D circles = 2;
  int circles_size() const;
  private:
  int _internal_circles_size() const;
  public:
  void clear_circles();
  ::Cir2D* mutable_circles(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Cir2D >*
      mutable_circles();
  private:
  const ::Cir2D& _internal_circles(int index) const;
  ::Cir2D* _internal_add_circles();
  public:
  const ::Cir2D& circles(int index) const;
  ::Cir2D* add_circles();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Cir2D >&
      circles() const;

  // repeated .Seg2D segments = 3;
  int segments_size() const;
  private:
  int _internal_segments_size() const;
  public:
  void clear_segments();
  ::Seg2D* mutable_segments(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Seg2D >*
      mutable_segments();
  private:
  const ::Seg2D& _internal_segments(int index) const;
  ::Seg2D* _internal_add_segments();
  public:
  const ::Seg2D& segments(int index) const;
  ::Seg2D* add_segments();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Seg2D >&
      segments() const;

  // repeated .Rec2D rects = 4;
  int rects_size() const;
  private:
  int _internal_rects_size() const;
  public:
  void clear_rects();
  ::Rec2D* mutable_rects(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Rec2D >*
      mutable_rects();
  private:
  const ::Rec2D& _internal_rects(int index) const;
  ::Rec2D* _internal_add_rects();
  public:
  const ::Rec2D& rects(int index) const;
  ::Rec2D* add_rects();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Rec2D >&
      rects() const;

  // repeated .Pol2D polygons = 5;
  int polygons_size() const;
  private:
  int _internal_polygons_size() const;
  public:
  void clear_polygons();
  ::Pol2D* mutable_polygons(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Pol2D >*
      mutable_polygons();
  private:
  const ::Pol2D& _internal_polygons(int index) const;
  ::Pol2D* _internal_add_polygons();
  public:
  const ::Pol2D& polygons(int index) const;
  ::Pol2D* add_polygons();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Pol2D >&
      polygons() const;

  // repeated .Tex2D texts = 6;
  int texts_size() const;
  private:
  int _internal_texts_size() const;
  public:
  void clear_texts();
  ::Tex2D* mutable_texts(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Tex2D >*
      mutable_texts();
  private:
  const ::Tex2D& _internal_texts(int index) const;
  ::Tex2D* _internal_add_texts();
  public:
  const ::Tex2D& texts(int index) const;
  ::Tex2D* add_texts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Tex2D >&
      texts() const;

  // @@protoc_insertion_point(class_scope:Draws)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Vec2D > vectors_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Cir2D > circles_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Seg2D > segments_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Rec2D > rects_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Pol2D > polygons_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Tex2D > texts_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_messages_5fparsian_5fsimurosot_5fdebugs_2eproto;
};
// -------------------------------------------------------------------

class Log :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Log) */ {
 public:
  Log();
  virtual ~Log();

  Log(const Log& from);
  Log(Log&& from) noexcept
    : Log() {
    *this = ::std::move(from);
  }

  inline Log& operator=(const Log& from) {
    CopyFrom(from);
    return *this;
  }
  inline Log& operator=(Log&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Log& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Log* internal_default_instance() {
    return reinterpret_cast<const Log*>(
               &_Log_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(Log& a, Log& b) {
    a.Swap(&b);
  }
  inline void Swap(Log* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Log* New() const final {
    return CreateMaybeMessage<Log>(nullptr);
  }

  Log* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Log>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Log& from);
  void MergeFrom(const Log& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Log* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Log";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_messages_5fparsian_5fsimurosot_5fdebugs_2eproto);
    return ::descriptor_table_messages_5fparsian_5fsimurosot_5fdebugs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgFieldNumber = 2,
    kFileFieldNumber = 3,
    kFunctionFieldNumber = 4,
    kLineFieldNumber = 5,
    kLevelFieldNumber = 1,
  };
  // string msg = 2;
  void clear_msg();
  const std::string& msg() const;
  void set_msg(const std::string& value);
  void set_msg(std::string&& value);
  void set_msg(const char* value);
  void set_msg(const char* value, size_t size);
  std::string* mutable_msg();
  std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // string file = 3;
  void clear_file();
  const std::string& file() const;
  void set_file(const std::string& value);
  void set_file(std::string&& value);
  void set_file(const char* value);
  void set_file(const char* value, size_t size);
  std::string* mutable_file();
  std::string* release_file();
  void set_allocated_file(std::string* file);
  private:
  const std::string& _internal_file() const;
  void _internal_set_file(const std::string& value);
  std::string* _internal_mutable_file();
  public:

  // string function = 4;
  void clear_function();
  const std::string& function() const;
  void set_function(const std::string& value);
  void set_function(std::string&& value);
  void set_function(const char* value);
  void set_function(const char* value, size_t size);
  std::string* mutable_function();
  std::string* release_function();
  void set_allocated_function(std::string* function);
  private:
  const std::string& _internal_function() const;
  void _internal_set_function(const std::string& value);
  std::string* _internal_mutable_function();
  public:

  // string line = 5;
  void clear_line();
  const std::string& line() const;
  void set_line(const std::string& value);
  void set_line(std::string&& value);
  void set_line(const char* value);
  void set_line(const char* value, size_t size);
  std::string* mutable_line();
  std::string* release_line();
  void set_allocated_line(std::string* line);
  private:
  const std::string& _internal_line() const;
  void _internal_set_line(const std::string& value);
  std::string* _internal_mutable_line();
  public:

  // .LogLevel level = 1;
  void clear_level();
  ::LogLevel level() const;
  void set_level(::LogLevel value);
  private:
  ::LogLevel _internal_level() const;
  void _internal_set_level(::LogLevel value);
  public:

  // @@protoc_insertion_point(class_scope:Log)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr function_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr line_;
  int level_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_messages_5fparsian_5fsimurosot_5fdebugs_2eproto;
};
// -------------------------------------------------------------------

class Logs :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Logs) */ {
 public:
  Logs();
  virtual ~Logs();

  Logs(const Logs& from);
  Logs(Logs&& from) noexcept
    : Logs() {
    *this = ::std::move(from);
  }

  inline Logs& operator=(const Logs& from) {
    CopyFrom(from);
    return *this;
  }
  inline Logs& operator=(Logs&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Logs& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Logs* internal_default_instance() {
    return reinterpret_cast<const Logs*>(
               &_Logs_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Logs& a, Logs& b) {
    a.Swap(&b);
  }
  inline void Swap(Logs* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Logs* New() const final {
    return CreateMaybeMessage<Logs>(nullptr);
  }

  Logs* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Logs>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Logs& from);
  void MergeFrom(const Logs& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Logs* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Logs";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_messages_5fparsian_5fsimurosot_5fdebugs_2eproto);
    return ::descriptor_table_messages_5fparsian_5fsimurosot_5fdebugs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgsFieldNumber = 1,
  };
  // repeated .Log msgs = 1;
  int msgs_size() const;
  private:
  int _internal_msgs_size() const;
  public:
  void clear_msgs();
  ::Log* mutable_msgs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Log >*
      mutable_msgs();
  private:
  const ::Log& _internal_msgs(int index) const;
  ::Log* _internal_add_msgs();
  public:
  const ::Log& msgs(int index) const;
  ::Log* add_msgs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Log >&
      msgs() const;

  // @@protoc_insertion_point(class_scope:Logs)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Log > msgs_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_messages_5fparsian_5fsimurosot_5fdebugs_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Color

// float r = 1;
inline void Color::clear_r() {
  r_ = 0;
}
inline float Color::_internal_r() const {
  return r_;
}
inline float Color::r() const {
  // @@protoc_insertion_point(field_get:Color.r)
  return _internal_r();
}
inline void Color::_internal_set_r(float value) {
  
  r_ = value;
}
inline void Color::set_r(float value) {
  _internal_set_r(value);
  // @@protoc_insertion_point(field_set:Color.r)
}

// float g = 2;
inline void Color::clear_g() {
  g_ = 0;
}
inline float Color::_internal_g() const {
  return g_;
}
inline float Color::g() const {
  // @@protoc_insertion_point(field_get:Color.g)
  return _internal_g();
}
inline void Color::_internal_set_g(float value) {
  
  g_ = value;
}
inline void Color::set_g(float value) {
  _internal_set_g(value);
  // @@protoc_insertion_point(field_set:Color.g)
}

// float b = 3;
inline void Color::clear_b() {
  b_ = 0;
}
inline float Color::_internal_b() const {
  return b_;
}
inline float Color::b() const {
  // @@protoc_insertion_point(field_get:Color.b)
  return _internal_b();
}
inline void Color::_internal_set_b(float value) {
  
  b_ = value;
}
inline void Color::set_b(float value) {
  _internal_set_b(value);
  // @@protoc_insertion_point(field_set:Color.b)
}

// float a = 4;
inline void Color::clear_a() {
  a_ = 0;
}
inline float Color::_internal_a() const {
  return a_;
}
inline float Color::a() const {
  // @@protoc_insertion_point(field_get:Color.a)
  return _internal_a();
}
inline void Color::_internal_set_a(float value) {
  
  a_ = value;
}
inline void Color::set_a(float value) {
  _internal_set_a(value);
  // @@protoc_insertion_point(field_set:Color.a)
}

// -------------------------------------------------------------------

// Vec2

// float x = 1;
inline void Vec2::clear_x() {
  x_ = 0;
}
inline float Vec2::_internal_x() const {
  return x_;
}
inline float Vec2::x() const {
  // @@protoc_insertion_point(field_get:Vec2.x)
  return _internal_x();
}
inline void Vec2::_internal_set_x(float value) {
  
  x_ = value;
}
inline void Vec2::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:Vec2.x)
}

// float y = 2;
inline void Vec2::clear_y() {
  y_ = 0;
}
inline float Vec2::_internal_y() const {
  return y_;
}
inline float Vec2::y() const {
  // @@protoc_insertion_point(field_get:Vec2.y)
  return _internal_y();
}
inline void Vec2::_internal_set_y(float value) {
  
  y_ = value;
}
inline void Vec2::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:Vec2.y)
}

// -------------------------------------------------------------------

// Vec2D

// float x = 1;
inline void Vec2D::clear_x() {
  x_ = 0;
}
inline float Vec2D::_internal_x() const {
  return x_;
}
inline float Vec2D::x() const {
  // @@protoc_insertion_point(field_get:Vec2D.x)
  return _internal_x();
}
inline void Vec2D::_internal_set_x(float value) {
  
  x_ = value;
}
inline void Vec2D::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:Vec2D.x)
}

// float y = 2;
inline void Vec2D::clear_y() {
  y_ = 0;
}
inline float Vec2D::_internal_y() const {
  return y_;
}
inline float Vec2D::y() const {
  // @@protoc_insertion_point(field_get:Vec2D.y)
  return _internal_y();
}
inline void Vec2D::_internal_set_y(float value) {
  
  y_ = value;
}
inline void Vec2D::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:Vec2D.y)
}

// .Color color = 3;
inline bool Vec2D::_internal_has_color() const {
  return this != internal_default_instance() && color_ != nullptr;
}
inline bool Vec2D::has_color() const {
  return _internal_has_color();
}
inline void Vec2D::clear_color() {
  if (GetArenaNoVirtual() == nullptr && color_ != nullptr) {
    delete color_;
  }
  color_ = nullptr;
}
inline const ::Color& Vec2D::_internal_color() const {
  const ::Color* p = color_;
  return p != nullptr ? *p : *reinterpret_cast<const ::Color*>(
      &::_Color_default_instance_);
}
inline const ::Color& Vec2D::color() const {
  // @@protoc_insertion_point(field_get:Vec2D.color)
  return _internal_color();
}
inline ::Color* Vec2D::release_color() {
  // @@protoc_insertion_point(field_release:Vec2D.color)
  
  ::Color* temp = color_;
  color_ = nullptr;
  return temp;
}
inline ::Color* Vec2D::_internal_mutable_color() {
  
  if (color_ == nullptr) {
    auto* p = CreateMaybeMessage<::Color>(GetArenaNoVirtual());
    color_ = p;
  }
  return color_;
}
inline ::Color* Vec2D::mutable_color() {
  // @@protoc_insertion_point(field_mutable:Vec2D.color)
  return _internal_mutable_color();
}
inline void Vec2D::set_allocated_color(::Color* color) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete color_;
  }
  if (color) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      color = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, color, submessage_arena);
    }
    
  } else {
    
  }
  color_ = color;
  // @@protoc_insertion_point(field_set_allocated:Vec2D.color)
}

// -------------------------------------------------------------------

// Cir2D

// .Vec2 center = 1;
inline bool Cir2D::_internal_has_center() const {
  return this != internal_default_instance() && center_ != nullptr;
}
inline bool Cir2D::has_center() const {
  return _internal_has_center();
}
inline void Cir2D::clear_center() {
  if (GetArenaNoVirtual() == nullptr && center_ != nullptr) {
    delete center_;
  }
  center_ = nullptr;
}
inline const ::Vec2& Cir2D::_internal_center() const {
  const ::Vec2* p = center_;
  return p != nullptr ? *p : *reinterpret_cast<const ::Vec2*>(
      &::_Vec2_default_instance_);
}
inline const ::Vec2& Cir2D::center() const {
  // @@protoc_insertion_point(field_get:Cir2D.center)
  return _internal_center();
}
inline ::Vec2* Cir2D::release_center() {
  // @@protoc_insertion_point(field_release:Cir2D.center)
  
  ::Vec2* temp = center_;
  center_ = nullptr;
  return temp;
}
inline ::Vec2* Cir2D::_internal_mutable_center() {
  
  if (center_ == nullptr) {
    auto* p = CreateMaybeMessage<::Vec2>(GetArenaNoVirtual());
    center_ = p;
  }
  return center_;
}
inline ::Vec2* Cir2D::mutable_center() {
  // @@protoc_insertion_point(field_mutable:Cir2D.center)
  return _internal_mutable_center();
}
inline void Cir2D::set_allocated_center(::Vec2* center) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete center_;
  }
  if (center) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      center = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, center, submessage_arena);
    }
    
  } else {
    
  }
  center_ = center;
  // @@protoc_insertion_point(field_set_allocated:Cir2D.center)
}

// float startAngle = 2;
inline void Cir2D::clear_startangle() {
  startangle_ = 0;
}
inline float Cir2D::_internal_startangle() const {
  return startangle_;
}
inline float Cir2D::startangle() const {
  // @@protoc_insertion_point(field_get:Cir2D.startAngle)
  return _internal_startangle();
}
inline void Cir2D::_internal_set_startangle(float value) {
  
  startangle_ = value;
}
inline void Cir2D::set_startangle(float value) {
  _internal_set_startangle(value);
  // @@protoc_insertion_point(field_set:Cir2D.startAngle)
}

// float endAngle = 3;
inline void Cir2D::clear_endangle() {
  endangle_ = 0;
}
inline float Cir2D::_internal_endangle() const {
  return endangle_;
}
inline float Cir2D::endangle() const {
  // @@protoc_insertion_point(field_get:Cir2D.endAngle)
  return _internal_endangle();
}
inline void Cir2D::_internal_set_endangle(float value) {
  
  endangle_ = value;
}
inline void Cir2D::set_endangle(float value) {
  _internal_set_endangle(value);
  // @@protoc_insertion_point(field_set:Cir2D.endAngle)
}

// float radius = 4;
inline void Cir2D::clear_radius() {
  radius_ = 0;
}
inline float Cir2D::_internal_radius() const {
  return radius_;
}
inline float Cir2D::radius() const {
  // @@protoc_insertion_point(field_get:Cir2D.radius)
  return _internal_radius();
}
inline void Cir2D::_internal_set_radius(float value) {
  
  radius_ = value;
}
inline void Cir2D::set_radius(float value) {
  _internal_set_radius(value);
  // @@protoc_insertion_point(field_set:Cir2D.radius)
}

// bool fill = 5;
inline void Cir2D::clear_fill() {
  fill_ = false;
}
inline bool Cir2D::_internal_fill() const {
  return fill_;
}
inline bool Cir2D::fill() const {
  // @@protoc_insertion_point(field_get:Cir2D.fill)
  return _internal_fill();
}
inline void Cir2D::_internal_set_fill(bool value) {
  
  fill_ = value;
}
inline void Cir2D::set_fill(bool value) {
  _internal_set_fill(value);
  // @@protoc_insertion_point(field_set:Cir2D.fill)
}

// .Color color = 6;
inline bool Cir2D::_internal_has_color() const {
  return this != internal_default_instance() && color_ != nullptr;
}
inline bool Cir2D::has_color() const {
  return _internal_has_color();
}
inline void Cir2D::clear_color() {
  if (GetArenaNoVirtual() == nullptr && color_ != nullptr) {
    delete color_;
  }
  color_ = nullptr;
}
inline const ::Color& Cir2D::_internal_color() const {
  const ::Color* p = color_;
  return p != nullptr ? *p : *reinterpret_cast<const ::Color*>(
      &::_Color_default_instance_);
}
inline const ::Color& Cir2D::color() const {
  // @@protoc_insertion_point(field_get:Cir2D.color)
  return _internal_color();
}
inline ::Color* Cir2D::release_color() {
  // @@protoc_insertion_point(field_release:Cir2D.color)
  
  ::Color* temp = color_;
  color_ = nullptr;
  return temp;
}
inline ::Color* Cir2D::_internal_mutable_color() {
  
  if (color_ == nullptr) {
    auto* p = CreateMaybeMessage<::Color>(GetArenaNoVirtual());
    color_ = p;
  }
  return color_;
}
inline ::Color* Cir2D::mutable_color() {
  // @@protoc_insertion_point(field_mutable:Cir2D.color)
  return _internal_mutable_color();
}
inline void Cir2D::set_allocated_color(::Color* color) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete color_;
  }
  if (color) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      color = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, color, submessage_arena);
    }
    
  } else {
    
  }
  color_ = color;
  // @@protoc_insertion_point(field_set_allocated:Cir2D.color)
}

// -------------------------------------------------------------------

// Seg2D

// .Vec2 origin = 1;
inline bool Seg2D::_internal_has_origin() const {
  return this != internal_default_instance() && origin_ != nullptr;
}
inline bool Seg2D::has_origin() const {
  return _internal_has_origin();
}
inline void Seg2D::clear_origin() {
  if (GetArenaNoVirtual() == nullptr && origin_ != nullptr) {
    delete origin_;
  }
  origin_ = nullptr;
}
inline const ::Vec2& Seg2D::_internal_origin() const {
  const ::Vec2* p = origin_;
  return p != nullptr ? *p : *reinterpret_cast<const ::Vec2*>(
      &::_Vec2_default_instance_);
}
inline const ::Vec2& Seg2D::origin() const {
  // @@protoc_insertion_point(field_get:Seg2D.origin)
  return _internal_origin();
}
inline ::Vec2* Seg2D::release_origin() {
  // @@protoc_insertion_point(field_release:Seg2D.origin)
  
  ::Vec2* temp = origin_;
  origin_ = nullptr;
  return temp;
}
inline ::Vec2* Seg2D::_internal_mutable_origin() {
  
  if (origin_ == nullptr) {
    auto* p = CreateMaybeMessage<::Vec2>(GetArenaNoVirtual());
    origin_ = p;
  }
  return origin_;
}
inline ::Vec2* Seg2D::mutable_origin() {
  // @@protoc_insertion_point(field_mutable:Seg2D.origin)
  return _internal_mutable_origin();
}
inline void Seg2D::set_allocated_origin(::Vec2* origin) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete origin_;
  }
  if (origin) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      origin = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, origin, submessage_arena);
    }
    
  } else {
    
  }
  origin_ = origin;
  // @@protoc_insertion_point(field_set_allocated:Seg2D.origin)
}

// .Vec2 terminal = 2;
inline bool Seg2D::_internal_has_terminal() const {
  return this != internal_default_instance() && terminal_ != nullptr;
}
inline bool Seg2D::has_terminal() const {
  return _internal_has_terminal();
}
inline void Seg2D::clear_terminal() {
  if (GetArenaNoVirtual() == nullptr && terminal_ != nullptr) {
    delete terminal_;
  }
  terminal_ = nullptr;
}
inline const ::Vec2& Seg2D::_internal_terminal() const {
  const ::Vec2* p = terminal_;
  return p != nullptr ? *p : *reinterpret_cast<const ::Vec2*>(
      &::_Vec2_default_instance_);
}
inline const ::Vec2& Seg2D::terminal() const {
  // @@protoc_insertion_point(field_get:Seg2D.terminal)
  return _internal_terminal();
}
inline ::Vec2* Seg2D::release_terminal() {
  // @@protoc_insertion_point(field_release:Seg2D.terminal)
  
  ::Vec2* temp = terminal_;
  terminal_ = nullptr;
  return temp;
}
inline ::Vec2* Seg2D::_internal_mutable_terminal() {
  
  if (terminal_ == nullptr) {
    auto* p = CreateMaybeMessage<::Vec2>(GetArenaNoVirtual());
    terminal_ = p;
  }
  return terminal_;
}
inline ::Vec2* Seg2D::mutable_terminal() {
  // @@protoc_insertion_point(field_mutable:Seg2D.terminal)
  return _internal_mutable_terminal();
}
inline void Seg2D::set_allocated_terminal(::Vec2* terminal) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete terminal_;
  }
  if (terminal) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      terminal = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, terminal, submessage_arena);
    }
    
  } else {
    
  }
  terminal_ = terminal;
  // @@protoc_insertion_point(field_set_allocated:Seg2D.terminal)
}

// .Color color = 3;
inline bool Seg2D::_internal_has_color() const {
  return this != internal_default_instance() && color_ != nullptr;
}
inline bool Seg2D::has_color() const {
  return _internal_has_color();
}
inline void Seg2D::clear_color() {
  if (GetArenaNoVirtual() == nullptr && color_ != nullptr) {
    delete color_;
  }
  color_ = nullptr;
}
inline const ::Color& Seg2D::_internal_color() const {
  const ::Color* p = color_;
  return p != nullptr ? *p : *reinterpret_cast<const ::Color*>(
      &::_Color_default_instance_);
}
inline const ::Color& Seg2D::color() const {
  // @@protoc_insertion_point(field_get:Seg2D.color)
  return _internal_color();
}
inline ::Color* Seg2D::release_color() {
  // @@protoc_insertion_point(field_release:Seg2D.color)
  
  ::Color* temp = color_;
  color_ = nullptr;
  return temp;
}
inline ::Color* Seg2D::_internal_mutable_color() {
  
  if (color_ == nullptr) {
    auto* p = CreateMaybeMessage<::Color>(GetArenaNoVirtual());
    color_ = p;
  }
  return color_;
}
inline ::Color* Seg2D::mutable_color() {
  // @@protoc_insertion_point(field_mutable:Seg2D.color)
  return _internal_mutable_color();
}
inline void Seg2D::set_allocated_color(::Color* color) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete color_;
  }
  if (color) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      color = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, color, submessage_arena);
    }
    
  } else {
    
  }
  color_ = color;
  // @@protoc_insertion_point(field_set_allocated:Seg2D.color)
}

// -------------------------------------------------------------------

// Rec2D

// .Vec2 topLeft = 1;
inline bool Rec2D::_internal_has_topleft() const {
  return this != internal_default_instance() && topleft_ != nullptr;
}
inline bool Rec2D::has_topleft() const {
  return _internal_has_topleft();
}
inline void Rec2D::clear_topleft() {
  if (GetArenaNoVirtual() == nullptr && topleft_ != nullptr) {
    delete topleft_;
  }
  topleft_ = nullptr;
}
inline const ::Vec2& Rec2D::_internal_topleft() const {
  const ::Vec2* p = topleft_;
  return p != nullptr ? *p : *reinterpret_cast<const ::Vec2*>(
      &::_Vec2_default_instance_);
}
inline const ::Vec2& Rec2D::topleft() const {
  // @@protoc_insertion_point(field_get:Rec2D.topLeft)
  return _internal_topleft();
}
inline ::Vec2* Rec2D::release_topleft() {
  // @@protoc_insertion_point(field_release:Rec2D.topLeft)
  
  ::Vec2* temp = topleft_;
  topleft_ = nullptr;
  return temp;
}
inline ::Vec2* Rec2D::_internal_mutable_topleft() {
  
  if (topleft_ == nullptr) {
    auto* p = CreateMaybeMessage<::Vec2>(GetArenaNoVirtual());
    topleft_ = p;
  }
  return topleft_;
}
inline ::Vec2* Rec2D::mutable_topleft() {
  // @@protoc_insertion_point(field_mutable:Rec2D.topLeft)
  return _internal_mutable_topleft();
}
inline void Rec2D::set_allocated_topleft(::Vec2* topleft) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete topleft_;
  }
  if (topleft) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      topleft = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, topleft, submessage_arena);
    }
    
  } else {
    
  }
  topleft_ = topleft;
  // @@protoc_insertion_point(field_set_allocated:Rec2D.topLeft)
}

// .Vec2 BotRight = 2;
inline bool Rec2D::_internal_has_botright() const {
  return this != internal_default_instance() && botright_ != nullptr;
}
inline bool Rec2D::has_botright() const {
  return _internal_has_botright();
}
inline void Rec2D::clear_botright() {
  if (GetArenaNoVirtual() == nullptr && botright_ != nullptr) {
    delete botright_;
  }
  botright_ = nullptr;
}
inline const ::Vec2& Rec2D::_internal_botright() const {
  const ::Vec2* p = botright_;
  return p != nullptr ? *p : *reinterpret_cast<const ::Vec2*>(
      &::_Vec2_default_instance_);
}
inline const ::Vec2& Rec2D::botright() const {
  // @@protoc_insertion_point(field_get:Rec2D.BotRight)
  return _internal_botright();
}
inline ::Vec2* Rec2D::release_botright() {
  // @@protoc_insertion_point(field_release:Rec2D.BotRight)
  
  ::Vec2* temp = botright_;
  botright_ = nullptr;
  return temp;
}
inline ::Vec2* Rec2D::_internal_mutable_botright() {
  
  if (botright_ == nullptr) {
    auto* p = CreateMaybeMessage<::Vec2>(GetArenaNoVirtual());
    botright_ = p;
  }
  return botright_;
}
inline ::Vec2* Rec2D::mutable_botright() {
  // @@protoc_insertion_point(field_mutable:Rec2D.BotRight)
  return _internal_mutable_botright();
}
inline void Rec2D::set_allocated_botright(::Vec2* botright) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete botright_;
  }
  if (botright) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      botright = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, botright, submessage_arena);
    }
    
  } else {
    
  }
  botright_ = botright;
  // @@protoc_insertion_point(field_set_allocated:Rec2D.BotRight)
}

// .Color color = 3;
inline bool Rec2D::_internal_has_color() const {
  return this != internal_default_instance() && color_ != nullptr;
}
inline bool Rec2D::has_color() const {
  return _internal_has_color();
}
inline void Rec2D::clear_color() {
  if (GetArenaNoVirtual() == nullptr && color_ != nullptr) {
    delete color_;
  }
  color_ = nullptr;
}
inline const ::Color& Rec2D::_internal_color() const {
  const ::Color* p = color_;
  return p != nullptr ? *p : *reinterpret_cast<const ::Color*>(
      &::_Color_default_instance_);
}
inline const ::Color& Rec2D::color() const {
  // @@protoc_insertion_point(field_get:Rec2D.color)
  return _internal_color();
}
inline ::Color* Rec2D::release_color() {
  // @@protoc_insertion_point(field_release:Rec2D.color)
  
  ::Color* temp = color_;
  color_ = nullptr;
  return temp;
}
inline ::Color* Rec2D::_internal_mutable_color() {
  
  if (color_ == nullptr) {
    auto* p = CreateMaybeMessage<::Color>(GetArenaNoVirtual());
    color_ = p;
  }
  return color_;
}
inline ::Color* Rec2D::mutable_color() {
  // @@protoc_insertion_point(field_mutable:Rec2D.color)
  return _internal_mutable_color();
}
inline void Rec2D::set_allocated_color(::Color* color) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete color_;
  }
  if (color) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      color = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, color, submessage_arena);
    }
    
  } else {
    
  }
  color_ = color;
  // @@protoc_insertion_point(field_set_allocated:Rec2D.color)
}

// bool fill = 4;
inline void Rec2D::clear_fill() {
  fill_ = false;
}
inline bool Rec2D::_internal_fill() const {
  return fill_;
}
inline bool Rec2D::fill() const {
  // @@protoc_insertion_point(field_get:Rec2D.fill)
  return _internal_fill();
}
inline void Rec2D::_internal_set_fill(bool value) {
  
  fill_ = value;
}
inline void Rec2D::set_fill(bool value) {
  _internal_set_fill(value);
  // @@protoc_insertion_point(field_set:Rec2D.fill)
}

// -------------------------------------------------------------------

// Tex2D

// .Vec2 pos = 1;
inline bool Tex2D::_internal_has_pos() const {
  return this != internal_default_instance() && pos_ != nullptr;
}
inline bool Tex2D::has_pos() const {
  return _internal_has_pos();
}
inline void Tex2D::clear_pos() {
  if (GetArenaNoVirtual() == nullptr && pos_ != nullptr) {
    delete pos_;
  }
  pos_ = nullptr;
}
inline const ::Vec2& Tex2D::_internal_pos() const {
  const ::Vec2* p = pos_;
  return p != nullptr ? *p : *reinterpret_cast<const ::Vec2*>(
      &::_Vec2_default_instance_);
}
inline const ::Vec2& Tex2D::pos() const {
  // @@protoc_insertion_point(field_get:Tex2D.pos)
  return _internal_pos();
}
inline ::Vec2* Tex2D::release_pos() {
  // @@protoc_insertion_point(field_release:Tex2D.pos)
  
  ::Vec2* temp = pos_;
  pos_ = nullptr;
  return temp;
}
inline ::Vec2* Tex2D::_internal_mutable_pos() {
  
  if (pos_ == nullptr) {
    auto* p = CreateMaybeMessage<::Vec2>(GetArenaNoVirtual());
    pos_ = p;
  }
  return pos_;
}
inline ::Vec2* Tex2D::mutable_pos() {
  // @@protoc_insertion_point(field_mutable:Tex2D.pos)
  return _internal_mutable_pos();
}
inline void Tex2D::set_allocated_pos(::Vec2* pos) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete pos_;
  }
  if (pos) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      pos = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pos, submessage_arena);
    }
    
  } else {
    
  }
  pos_ = pos;
  // @@protoc_insertion_point(field_set_allocated:Tex2D.pos)
}

// float size = 2;
inline void Tex2D::clear_size() {
  size_ = 0;
}
inline float Tex2D::_internal_size() const {
  return size_;
}
inline float Tex2D::size() const {
  // @@protoc_insertion_point(field_get:Tex2D.size)
  return _internal_size();
}
inline void Tex2D::_internal_set_size(float value) {
  
  size_ = value;
}
inline void Tex2D::set_size(float value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:Tex2D.size)
}

// .Color color = 3;
inline bool Tex2D::_internal_has_color() const {
  return this != internal_default_instance() && color_ != nullptr;
}
inline bool Tex2D::has_color() const {
  return _internal_has_color();
}
inline void Tex2D::clear_color() {
  if (GetArenaNoVirtual() == nullptr && color_ != nullptr) {
    delete color_;
  }
  color_ = nullptr;
}
inline const ::Color& Tex2D::_internal_color() const {
  const ::Color* p = color_;
  return p != nullptr ? *p : *reinterpret_cast<const ::Color*>(
      &::_Color_default_instance_);
}
inline const ::Color& Tex2D::color() const {
  // @@protoc_insertion_point(field_get:Tex2D.color)
  return _internal_color();
}
inline ::Color* Tex2D::release_color() {
  // @@protoc_insertion_point(field_release:Tex2D.color)
  
  ::Color* temp = color_;
  color_ = nullptr;
  return temp;
}
inline ::Color* Tex2D::_internal_mutable_color() {
  
  if (color_ == nullptr) {
    auto* p = CreateMaybeMessage<::Color>(GetArenaNoVirtual());
    color_ = p;
  }
  return color_;
}
inline ::Color* Tex2D::mutable_color() {
  // @@protoc_insertion_point(field_mutable:Tex2D.color)
  return _internal_mutable_color();
}
inline void Tex2D::set_allocated_color(::Color* color) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete color_;
  }
  if (color) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      color = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, color, submessage_arena);
    }
    
  } else {
    
  }
  color_ = color;
  // @@protoc_insertion_point(field_set_allocated:Tex2D.color)
}

// string data = 4;
inline void Tex2D::clear_data() {
  data_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Tex2D::data() const {
  // @@protoc_insertion_point(field_get:Tex2D.data)
  return _internal_data();
}
inline void Tex2D::set_data(const std::string& value) {
  _internal_set_data(value);
  // @@protoc_insertion_point(field_set:Tex2D.data)
}
inline std::string* Tex2D::mutable_data() {
  // @@protoc_insertion_point(field_mutable:Tex2D.data)
  return _internal_mutable_data();
}
inline const std::string& Tex2D::_internal_data() const {
  return data_.GetNoArena();
}
inline void Tex2D::_internal_set_data(const std::string& value) {
  
  data_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void Tex2D::set_data(std::string&& value) {
  
  data_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Tex2D.data)
}
inline void Tex2D::set_data(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  data_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Tex2D.data)
}
inline void Tex2D::set_data(const char* value, size_t size) {
  
  data_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Tex2D.data)
}
inline std::string* Tex2D::_internal_mutable_data() {
  
  return data_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Tex2D::release_data() {
  // @@protoc_insertion_point(field_release:Tex2D.data)
  
  return data_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Tex2D::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  data_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:Tex2D.data)
}

// -------------------------------------------------------------------

// Pol2D

// repeated .Vec2 vectors = 1;
inline int Pol2D::_internal_vectors_size() const {
  return vectors_.size();
}
inline int Pol2D::vectors_size() const {
  return _internal_vectors_size();
}
inline void Pol2D::clear_vectors() {
  vectors_.Clear();
}
inline ::Vec2* Pol2D::mutable_vectors(int index) {
  // @@protoc_insertion_point(field_mutable:Pol2D.vectors)
  return vectors_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Vec2 >*
Pol2D::mutable_vectors() {
  // @@protoc_insertion_point(field_mutable_list:Pol2D.vectors)
  return &vectors_;
}
inline const ::Vec2& Pol2D::_internal_vectors(int index) const {
  return vectors_.Get(index);
}
inline const ::Vec2& Pol2D::vectors(int index) const {
  // @@protoc_insertion_point(field_get:Pol2D.vectors)
  return _internal_vectors(index);
}
inline ::Vec2* Pol2D::_internal_add_vectors() {
  return vectors_.Add();
}
inline ::Vec2* Pol2D::add_vectors() {
  // @@protoc_insertion_point(field_add:Pol2D.vectors)
  return _internal_add_vectors();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Vec2 >&
Pol2D::vectors() const {
  // @@protoc_insertion_point(field_list:Pol2D.vectors)
  return vectors_;
}

// .Color color = 2;
inline bool Pol2D::_internal_has_color() const {
  return this != internal_default_instance() && color_ != nullptr;
}
inline bool Pol2D::has_color() const {
  return _internal_has_color();
}
inline void Pol2D::clear_color() {
  if (GetArenaNoVirtual() == nullptr && color_ != nullptr) {
    delete color_;
  }
  color_ = nullptr;
}
inline const ::Color& Pol2D::_internal_color() const {
  const ::Color* p = color_;
  return p != nullptr ? *p : *reinterpret_cast<const ::Color*>(
      &::_Color_default_instance_);
}
inline const ::Color& Pol2D::color() const {
  // @@protoc_insertion_point(field_get:Pol2D.color)
  return _internal_color();
}
inline ::Color* Pol2D::release_color() {
  // @@protoc_insertion_point(field_release:Pol2D.color)
  
  ::Color* temp = color_;
  color_ = nullptr;
  return temp;
}
inline ::Color* Pol2D::_internal_mutable_color() {
  
  if (color_ == nullptr) {
    auto* p = CreateMaybeMessage<::Color>(GetArenaNoVirtual());
    color_ = p;
  }
  return color_;
}
inline ::Color* Pol2D::mutable_color() {
  // @@protoc_insertion_point(field_mutable:Pol2D.color)
  return _internal_mutable_color();
}
inline void Pol2D::set_allocated_color(::Color* color) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete color_;
  }
  if (color) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      color = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, color, submessage_arena);
    }
    
  } else {
    
  }
  color_ = color;
  // @@protoc_insertion_point(field_set_allocated:Pol2D.color)
}

// bool fill = 3;
inline void Pol2D::clear_fill() {
  fill_ = false;
}
inline bool Pol2D::_internal_fill() const {
  return fill_;
}
inline bool Pol2D::fill() const {
  // @@protoc_insertion_point(field_get:Pol2D.fill)
  return _internal_fill();
}
inline void Pol2D::_internal_set_fill(bool value) {
  
  fill_ = value;
}
inline void Pol2D::set_fill(bool value) {
  _internal_set_fill(value);
  // @@protoc_insertion_point(field_set:Pol2D.fill)
}

// -------------------------------------------------------------------

// Draws

// repeated .Vec2D vectors = 1;
inline int Draws::_internal_vectors_size() const {
  return vectors_.size();
}
inline int Draws::vectors_size() const {
  return _internal_vectors_size();
}
inline void Draws::clear_vectors() {
  vectors_.Clear();
}
inline ::Vec2D* Draws::mutable_vectors(int index) {
  // @@protoc_insertion_point(field_mutable:Draws.vectors)
  return vectors_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Vec2D >*
Draws::mutable_vectors() {
  // @@protoc_insertion_point(field_mutable_list:Draws.vectors)
  return &vectors_;
}
inline const ::Vec2D& Draws::_internal_vectors(int index) const {
  return vectors_.Get(index);
}
inline const ::Vec2D& Draws::vectors(int index) const {
  // @@protoc_insertion_point(field_get:Draws.vectors)
  return _internal_vectors(index);
}
inline ::Vec2D* Draws::_internal_add_vectors() {
  return vectors_.Add();
}
inline ::Vec2D* Draws::add_vectors() {
  // @@protoc_insertion_point(field_add:Draws.vectors)
  return _internal_add_vectors();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Vec2D >&
Draws::vectors() const {
  // @@protoc_insertion_point(field_list:Draws.vectors)
  return vectors_;
}

// repeated .Cir2D circles = 2;
inline int Draws::_internal_circles_size() const {
  return circles_.size();
}
inline int Draws::circles_size() const {
  return _internal_circles_size();
}
inline void Draws::clear_circles() {
  circles_.Clear();
}
inline ::Cir2D* Draws::mutable_circles(int index) {
  // @@protoc_insertion_point(field_mutable:Draws.circles)
  return circles_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Cir2D >*
Draws::mutable_circles() {
  // @@protoc_insertion_point(field_mutable_list:Draws.circles)
  return &circles_;
}
inline const ::Cir2D& Draws::_internal_circles(int index) const {
  return circles_.Get(index);
}
inline const ::Cir2D& Draws::circles(int index) const {
  // @@protoc_insertion_point(field_get:Draws.circles)
  return _internal_circles(index);
}
inline ::Cir2D* Draws::_internal_add_circles() {
  return circles_.Add();
}
inline ::Cir2D* Draws::add_circles() {
  // @@protoc_insertion_point(field_add:Draws.circles)
  return _internal_add_circles();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Cir2D >&
Draws::circles() const {
  // @@protoc_insertion_point(field_list:Draws.circles)
  return circles_;
}

// repeated .Seg2D segments = 3;
inline int Draws::_internal_segments_size() const {
  return segments_.size();
}
inline int Draws::segments_size() const {
  return _internal_segments_size();
}
inline void Draws::clear_segments() {
  segments_.Clear();
}
inline ::Seg2D* Draws::mutable_segments(int index) {
  // @@protoc_insertion_point(field_mutable:Draws.segments)
  return segments_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Seg2D >*
Draws::mutable_segments() {
  // @@protoc_insertion_point(field_mutable_list:Draws.segments)
  return &segments_;
}
inline const ::Seg2D& Draws::_internal_segments(int index) const {
  return segments_.Get(index);
}
inline const ::Seg2D& Draws::segments(int index) const {
  // @@protoc_insertion_point(field_get:Draws.segments)
  return _internal_segments(index);
}
inline ::Seg2D* Draws::_internal_add_segments() {
  return segments_.Add();
}
inline ::Seg2D* Draws::add_segments() {
  // @@protoc_insertion_point(field_add:Draws.segments)
  return _internal_add_segments();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Seg2D >&
Draws::segments() const {
  // @@protoc_insertion_point(field_list:Draws.segments)
  return segments_;
}

// repeated .Rec2D rects = 4;
inline int Draws::_internal_rects_size() const {
  return rects_.size();
}
inline int Draws::rects_size() const {
  return _internal_rects_size();
}
inline void Draws::clear_rects() {
  rects_.Clear();
}
inline ::Rec2D* Draws::mutable_rects(int index) {
  // @@protoc_insertion_point(field_mutable:Draws.rects)
  return rects_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Rec2D >*
Draws::mutable_rects() {
  // @@protoc_insertion_point(field_mutable_list:Draws.rects)
  return &rects_;
}
inline const ::Rec2D& Draws::_internal_rects(int index) const {
  return rects_.Get(index);
}
inline const ::Rec2D& Draws::rects(int index) const {
  // @@protoc_insertion_point(field_get:Draws.rects)
  return _internal_rects(index);
}
inline ::Rec2D* Draws::_internal_add_rects() {
  return rects_.Add();
}
inline ::Rec2D* Draws::add_rects() {
  // @@protoc_insertion_point(field_add:Draws.rects)
  return _internal_add_rects();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Rec2D >&
Draws::rects() const {
  // @@protoc_insertion_point(field_list:Draws.rects)
  return rects_;
}

// repeated .Pol2D polygons = 5;
inline int Draws::_internal_polygons_size() const {
  return polygons_.size();
}
inline int Draws::polygons_size() const {
  return _internal_polygons_size();
}
inline void Draws::clear_polygons() {
  polygons_.Clear();
}
inline ::Pol2D* Draws::mutable_polygons(int index) {
  // @@protoc_insertion_point(field_mutable:Draws.polygons)
  return polygons_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Pol2D >*
Draws::mutable_polygons() {
  // @@protoc_insertion_point(field_mutable_list:Draws.polygons)
  return &polygons_;
}
inline const ::Pol2D& Draws::_internal_polygons(int index) const {
  return polygons_.Get(index);
}
inline const ::Pol2D& Draws::polygons(int index) const {
  // @@protoc_insertion_point(field_get:Draws.polygons)
  return _internal_polygons(index);
}
inline ::Pol2D* Draws::_internal_add_polygons() {
  return polygons_.Add();
}
inline ::Pol2D* Draws::add_polygons() {
  // @@protoc_insertion_point(field_add:Draws.polygons)
  return _internal_add_polygons();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Pol2D >&
Draws::polygons() const {
  // @@protoc_insertion_point(field_list:Draws.polygons)
  return polygons_;
}

// repeated .Tex2D texts = 6;
inline int Draws::_internal_texts_size() const {
  return texts_.size();
}
inline int Draws::texts_size() const {
  return _internal_texts_size();
}
inline void Draws::clear_texts() {
  texts_.Clear();
}
inline ::Tex2D* Draws::mutable_texts(int index) {
  // @@protoc_insertion_point(field_mutable:Draws.texts)
  return texts_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Tex2D >*
Draws::mutable_texts() {
  // @@protoc_insertion_point(field_mutable_list:Draws.texts)
  return &texts_;
}
inline const ::Tex2D& Draws::_internal_texts(int index) const {
  return texts_.Get(index);
}
inline const ::Tex2D& Draws::texts(int index) const {
  // @@protoc_insertion_point(field_get:Draws.texts)
  return _internal_texts(index);
}
inline ::Tex2D* Draws::_internal_add_texts() {
  return texts_.Add();
}
inline ::Tex2D* Draws::add_texts() {
  // @@protoc_insertion_point(field_add:Draws.texts)
  return _internal_add_texts();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Tex2D >&
Draws::texts() const {
  // @@protoc_insertion_point(field_list:Draws.texts)
  return texts_;
}

// -------------------------------------------------------------------

// Log

// .LogLevel level = 1;
inline void Log::clear_level() {
  level_ = 0;
}
inline ::LogLevel Log::_internal_level() const {
  return static_cast< ::LogLevel >(level_);
}
inline ::LogLevel Log::level() const {
  // @@protoc_insertion_point(field_get:Log.level)
  return _internal_level();
}
inline void Log::_internal_set_level(::LogLevel value) {
  
  level_ = value;
}
inline void Log::set_level(::LogLevel value) {
  _internal_set_level(value);
  // @@protoc_insertion_point(field_set:Log.level)
}

// string msg = 2;
inline void Log::clear_msg() {
  msg_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Log::msg() const {
  // @@protoc_insertion_point(field_get:Log.msg)
  return _internal_msg();
}
inline void Log::set_msg(const std::string& value) {
  _internal_set_msg(value);
  // @@protoc_insertion_point(field_set:Log.msg)
}
inline std::string* Log::mutable_msg() {
  // @@protoc_insertion_point(field_mutable:Log.msg)
  return _internal_mutable_msg();
}
inline const std::string& Log::_internal_msg() const {
  return msg_.GetNoArena();
}
inline void Log::_internal_set_msg(const std::string& value) {
  
  msg_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void Log::set_msg(std::string&& value) {
  
  msg_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Log.msg)
}
inline void Log::set_msg(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  msg_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Log.msg)
}
inline void Log::set_msg(const char* value, size_t size) {
  
  msg_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Log.msg)
}
inline std::string* Log::_internal_mutable_msg() {
  
  return msg_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Log::release_msg() {
  // @@protoc_insertion_point(field_release:Log.msg)
  
  return msg_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Log::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  msg_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), msg);
  // @@protoc_insertion_point(field_set_allocated:Log.msg)
}

// string file = 3;
inline void Log::clear_file() {
  file_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Log::file() const {
  // @@protoc_insertion_point(field_get:Log.file)
  return _internal_file();
}
inline void Log::set_file(const std::string& value) {
  _internal_set_file(value);
  // @@protoc_insertion_point(field_set:Log.file)
}
inline std::string* Log::mutable_file() {
  // @@protoc_insertion_point(field_mutable:Log.file)
  return _internal_mutable_file();
}
inline const std::string& Log::_internal_file() const {
  return file_.GetNoArena();
}
inline void Log::_internal_set_file(const std::string& value) {
  
  file_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void Log::set_file(std::string&& value) {
  
  file_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Log.file)
}
inline void Log::set_file(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  file_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Log.file)
}
inline void Log::set_file(const char* value, size_t size) {
  
  file_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Log.file)
}
inline std::string* Log::_internal_mutable_file() {
  
  return file_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Log::release_file() {
  // @@protoc_insertion_point(field_release:Log.file)
  
  return file_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Log::set_allocated_file(std::string* file) {
  if (file != nullptr) {
    
  } else {
    
  }
  file_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), file);
  // @@protoc_insertion_point(field_set_allocated:Log.file)
}

// string function = 4;
inline void Log::clear_function() {
  function_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Log::function() const {
  // @@protoc_insertion_point(field_get:Log.function)
  return _internal_function();
}
inline void Log::set_function(const std::string& value) {
  _internal_set_function(value);
  // @@protoc_insertion_point(field_set:Log.function)
}
inline std::string* Log::mutable_function() {
  // @@protoc_insertion_point(field_mutable:Log.function)
  return _internal_mutable_function();
}
inline const std::string& Log::_internal_function() const {
  return function_.GetNoArena();
}
inline void Log::_internal_set_function(const std::string& value) {
  
  function_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void Log::set_function(std::string&& value) {
  
  function_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Log.function)
}
inline void Log::set_function(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  function_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Log.function)
}
inline void Log::set_function(const char* value, size_t size) {
  
  function_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Log.function)
}
inline std::string* Log::_internal_mutable_function() {
  
  return function_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Log::release_function() {
  // @@protoc_insertion_point(field_release:Log.function)
  
  return function_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Log::set_allocated_function(std::string* function) {
  if (function != nullptr) {
    
  } else {
    
  }
  function_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), function);
  // @@protoc_insertion_point(field_set_allocated:Log.function)
}

// string line = 5;
inline void Log::clear_line() {
  line_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Log::line() const {
  // @@protoc_insertion_point(field_get:Log.line)
  return _internal_line();
}
inline void Log::set_line(const std::string& value) {
  _internal_set_line(value);
  // @@protoc_insertion_point(field_set:Log.line)
}
inline std::string* Log::mutable_line() {
  // @@protoc_insertion_point(field_mutable:Log.line)
  return _internal_mutable_line();
}
inline const std::string& Log::_internal_line() const {
  return line_.GetNoArena();
}
inline void Log::_internal_set_line(const std::string& value) {
  
  line_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void Log::set_line(std::string&& value) {
  
  line_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Log.line)
}
inline void Log::set_line(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  line_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Log.line)
}
inline void Log::set_line(const char* value, size_t size) {
  
  line_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Log.line)
}
inline std::string* Log::_internal_mutable_line() {
  
  return line_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Log::release_line() {
  // @@protoc_insertion_point(field_release:Log.line)
  
  return line_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Log::set_allocated_line(std::string* line) {
  if (line != nullptr) {
    
  } else {
    
  }
  line_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), line);
  // @@protoc_insertion_point(field_set_allocated:Log.line)
}

// -------------------------------------------------------------------

// Logs

// repeated .Log msgs = 1;
inline int Logs::_internal_msgs_size() const {
  return msgs_.size();
}
inline int Logs::msgs_size() const {
  return _internal_msgs_size();
}
inline void Logs::clear_msgs() {
  msgs_.Clear();
}
inline ::Log* Logs::mutable_msgs(int index) {
  // @@protoc_insertion_point(field_mutable:Logs.msgs)
  return msgs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Log >*
Logs::mutable_msgs() {
  // @@protoc_insertion_point(field_mutable_list:Logs.msgs)
  return &msgs_;
}
inline const ::Log& Logs::_internal_msgs(int index) const {
  return msgs_.Get(index);
}
inline const ::Log& Logs::msgs(int index) const {
  // @@protoc_insertion_point(field_get:Logs.msgs)
  return _internal_msgs(index);
}
inline ::Log* Logs::_internal_add_msgs() {
  return msgs_.Add();
}
inline ::Log* Logs::add_msgs() {
  // @@protoc_insertion_point(field_add:Logs.msgs)
  return _internal_add_msgs();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Log >&
Logs::msgs() const {
  // @@protoc_insertion_point(field_list:Logs.msgs)
  return msgs_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::LogLevel> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::LogLevel>() {
  return ::LogLevel_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_messages_5fparsian_5fsimurosot_5fdebugs_2eproto
